---
title: 垃圾收集与内存分配
date: 2019-01-16
comments: true 
tags:
- JVM
categories:  
- Java虚拟机
---

## 垃圾收集
垃圾收集（`Garbage Collection`), 俗称 `GC`。在系统中哪些内存需要回收？什么时候回收？怎样回收呢？当垃圾收集成为系统达到性能最优的阻碍时，我们就需要针对垃圾收集进行必要的监控与处理。

## 对象是否存活？
`Java`堆中存放几乎所有对象实例，垃圾收集器在回收对象时需要判断对象是否存活。哪些方法能够判断对象可以被回收呢？   
1). 引用计数算法   
给对象添加一个引用计数器，每当引用一次计数器 + 1， 引用失效 - 1。   
优点：实现简单，判定效率高。   
缺点：无法判断对象之间相互引用的问题。   
2). 可达性分析算法   
基本思路是通过`GC Roots`的对象作为起始点，向下开始搜索，所走过的路径成为引用链（Reference Chain）,当一个对象到 `GC Roots` 没有任何引用链相连时，表示该对象不可用，即是可以被回收的对象。   
在 `Java` 语言中，可作为`GC Roots`的对象包括下面几种：   
(1).虚拟机栈（栈帧中的本地变量表)中引用的对象。   
(2).方法区中类静态属性引用的对象。   
(3).方法区中常量引用的对象。   
(4).本地方法栈中JNI引用的对象。   

## 对象引用
`Java`中对对象的引用分为强引用，软引用，弱引用，虚引用四种，四种引用的强度依次递减。   
1).强引用指的是类似`Object object = new Object()` 这类引用，只要强引用存在，引用的对象永远不会被垃圾收集器回收。   
2).软引用描述的是有用但非必需的对象，对于软引用关联的对象，在系统将要发生内存溢出之前，系统将会把这些对象进行二次回收，如果这次回收还没有足够的内存，才会发生内存溢出异常。   
3).弱引用也是描述非必需的对象，但是它的强度比软引用更弱一些， 被弱引用关联的对象只能生存到一下次垃圾收集之前。当垃圾回收的时候，无论内存足够，被弱引用关联的对象都会被回收。   
4).虚引用是最弱的一种引用关系，若有若无。

## 垃圾收集算法
1).标记-清除算法   
先扫描并标记需要回收的对象，然后清除。标记和清除的效率都不是很高。   
2).复制算法   
把内存分为两块，当使用的一块内存不足时，将所有存活的对象复制到另一块，回收当前一整块
内存被分为eden区survivor 区，eden:survivor = 8:1   
3).标记整理算法      
标记出需要清理的对象，然后其余对象移动到另一端      
4).分代收集算法  （最优法）    
新生代使用复制算法  （新生代对象存活时间短，采用复制算法）   
永久代使用其他两种算法 （永久代对象存活时间较长）   
## 垃圾收集器
Serial 是单线程收集器，并且工作时必须暂停其他线程工作。   
ParNew 是 Serial 收集器的多线程版本，支持多条垃圾收集器并行工作。   
Parallel Scavenge 是一个新生代收集器，使用复制算法的收集器，也是并行的多线程收集器。   
Serial Old 是 Serial 收集器的老年代版本，也是一个单线程收集器，使用的是 标记-整理算法。   
Parallel Old 是 Parallel Scavenge 的老年代版本，使用多线程 和 标记-整理算法。   
CMS 是 以一种以获取最短回收停顿时间为目标的收集器，采用的是标记-清除算法。 停顿时间短，用户体验好，目前来看 CMS 收集器非常符合这类应用的需求。
G1收集器的优势：并行与并发， 分代收集， 空间整理 （标记整理算法，复制算法）。
## GC
对象在新生代Eden区中分配，当区域内存不足时，将会发生Minor GC（称为新生代GC)。      
对发生在老年代的GC称为Major GC， Major GC会比Minor GC的速度慢10倍以上。    
为了计算哪些对象在新生代，那些对象在老年代，虚拟机给每个对象定义了年龄计数器， 对象在Eden区发生了 Minor GC后任然存活并且能够被 Survivor容纳的话，将会移到Survivor区域，并且设置年龄为1，
对象每熬过一次Minor GC，年龄 +1。当对象年龄达到晋升老年代阈值时，晋升到老年代。（默认年龄为15岁， 可以通过参数 -XX： MaxTenuringThreshold)设置。  